
/*
 * File responsible for databinding the grid for a Camphora Five generated app.
 *
 * Optionally pass in [id], at which case, only the specified database [id] item 
 * will be re-databound, and no other items will be touched.
 *
 * You can also pass in [feed-more] and set its value to boolean "true", 
 * at which point the existing items will not be cleared, but rather the grid 
 * will have 25 more items appended to itself.
 */





/*
 * Signal node, to separate arguments from the rest of our lambda.
 */
.signal





/*
 * Sanity checking arguments.
 */
micro.lambda.contract.optional:x:/..
  offset:long
  id:long
  feed-more:bool





/*
 * Default values, used if no arguments are given.
 */
.defaults
  offset:long:0





/*
 * Figuring out if a query search parameter was supplied.
 */
p5.web.query.get:q





/*
 * Figuring out path of app's "/helpers/" folder.
 */
split:x:/..?name
  =:/
set:x:/@split/0/-
join:x:/@split/*?name
  sep:/





/*
 * Loading app declaration file.
 */
load-file:/{0}/app-manifest.hl
  :x:/@join?value





/*
 * Splitting URL, to figure out which type of request this is.
 *
 * Candidates are "/tag" request for instance.
 */
split:x:/../*/url?value
  =:/





/*
 * Creating our SQL fields definition, by figuring out which columns are supposed to be visible in
 * the datagrid.
 */
_cols
for-each:x:/@load-file/*/*/field

  /*
   * Checking if field is supposed to be visible in grid.
   */
  if:x:/@_dp/#/*/show?value

    /*
     * Adding column to SQL.
     */
    set:x:/@_cols?value
      src:{0},{1}
        :x:/@_cols?value
        :x:/@_dp/#/*/name?value





/*
 * Trimming away redundant "," on columns declaration.
 */
set:x:/@_cols?value
  trim:x:/@_cols?value
    chars:,





/*
 * Creating our SQL "where" statement, according to [p5.web.query.get] and "tag" requested.
 */
_where
_tag
for-each:x:/@load-file/*/*/field

  /*
   * Checking if we have a [tag] condition.
   */
  if:x:/@split/*?count
    >:int:2
    and:x:/@split/1?name
      =:tag

    /*
     * User requested items having a #hash-tag, now checking if currently iterated
     * field is a [textarea] type of field, and if so, we add it as a criteria.
     */
    if:x:/@_dp/#/*/type?value
      =:textarea

      /*
       * Currently iterated [field] is a [textarea] field, and user requested a 
       * specific #hash-tag - Making sure we add our #hash-tag condition.
       */
      set:x:/@_tag?value
        src:"{0} regexp @tag"
          :x:/@_dp/#/*/name?value
      eval-x:x:/+/*/*
      add:x:/../*/p5.mysql.connect/*/p5.mysql.select
        src
          @tag:#{0}
            :x:/@split/2?name

  /*
   * Checking if we have a [p5.web.query.get] condition.
   */
  if:x:/@p5.web.query.get/*?value

    /*
     * Query parameter was given, making sure we create our "where" condition.
     */
    if:x:/@_where?value

      /*
       * Adding "or" parts to SQL.
       */
      set:x:/@_where?value
        src:"{0} or "
          :x:/@_where?value

    else

      /*
       * Adding first parts of our "where" clause.
       */
      set:x:/@_where?value
        src:" where ("

      /*
       * Making sure we pass in [@filter] to [p5.mysql.select]
       */
      add:x:/../*/p5.mysql.connect/*/p5.mysql.select
        src
          @filter:"%{0}%"
            :x:/@p5.web.query.get/*?value

    /*
     * Adding up "where" for currently iterated column.
     */
    set:x:/@_where?value
      src:@"{0}`{1}` like @filter"
        :x:/@_where?value
        :x:/@_dp/#/*/name?value





/*
 * Adding closing ")" to where clause.
 */
if:x:/@_where?value
  set:x:/@_where?value
    src:"{0})"
      :x:/@_where?value





/*
 * Checking if user requested a tag, and massaging "where" parts accordingly.
 */
if:x:/@_tag?value
  if:x:/@_where?value
    set:x:/@_tag?value
      src:" and {0}"
        :x:/@_tag?value
  else
    set:x:/@_tag?value
      src:" where {0}"
        :x:/@_tag?value





/*
 * Checking if caller supplied an [id] argument.
 */
if:x:/@.signal/--/id?value

  /*
   * [id] argument was supplied, modifying where clause to accommodate for 
   * only specified id.
   */
  if:x:/@_where?value

    /*
     * Adding "id" clause as AND parameter to SQL.
     */
    set:x:/@_where?value
      src:@"{0} and id = @id"
        :x:/@_where?value

  else

    /*
     * Adding "id" clause as main where parts to SQL.
     */
    set:x:/@_where?value
      src:@" where id = @id"

  /*
   * Adding [@id] parameter to SQL.
   */
  add:x:/../*/p5.mysql.connect/*/p5.mysql.select
    src
      @id:x:/../*/id?value





/*
 * Checking if user is allowed to edit data in the system, for later references.
 */
p5.web.viewstate.get:camphora.editing-allowed





/*
 * Checking if this is a [feed-more] invocation, at which point we add an argument
 * to our SQL, which only selects items with a lower ID than what was previously selected.
 */
_feed
if:x:/../*/feed-more?value

  /*
   * Caller requested to feed grid with additional items, and not to re-databind grid.
   *
   * First checking if we have some other filtering arguments, which helps us to
   * determine how to dynamically build our "id >" argument.
   */
  if:x:/@_where?value
    or:x:/@_tag?value

    /*
     * Adding additional argument to SQL.
     */
    set:x:/@_feed?value
      src:" and "

  else

    /*
     * Feed argument is only argument.
     */
    set:x:/@_feed?value
      src:" where "

  /*
   * Retrieving last seen database ID, and parametrizing our SQL accordingly.
   */
  p5.web.viewstate.get:camphora.last-item
  set:x:/@_feed?value
    src:{0}{1}
      :x:/@_feed?value
      :@"id > @id"

  /*
   * Adding parameter to SQL invocation.
   */
  eval-x:x:/+/*/*
  add:x:/../**/p5.mysql.select
    src
      @id:x:/@p5.web.viewstate.get/*?value





/*
 * Loading file containing edit-template widgets.
 */
load-file:/modules/{0}/helpers/edit-item-template-widgets.hl
  :x:/../*/split/[0,1]/0/-2?name





/*
 * Opening database connection.
 */
p5.mysql.connect:[camphora]

  /*
   * Executing SQL query, now parametrized accordingly.
   */
  p5.mysql.select:@"select id, {0} from `{1}`{2}{3}{4} order by id limit 25 offset @offset"
    :x:/@_cols?value
    :x:/../*/split/[0,1]/0/-2?name
    :x:/@_where?value
    :x:/@_tag?value
    :x:/@_feed?value
    @offset:x:(/../*/offset|/../*/.defaults/*/offset)/$?value

  /*
   * Storing ID from last record from above SQL in viewstate, to be able to know
   * from which point we should keep on feeding items, if file is invoked later with
   * a [feed-more] argument.
   */
  p5.web.viewstate.set:camphora.last-item
    src:x:/@p5.mysql.select/0/-/*/id?value

  /*
   * Checking if this is the end of our dataset, and if so, informing client to
   * stop polling server for new data when scrolling to the bottom occurs.
   */
  if:x:/@p5.mysql.select/*?count
    =:int:0
    p5.web.send-javascript:"p5.camphora_end_of_dataset = true;"

  /*
   * Looping through above results, and creating a row in grid for each row in database.
   */
  for-each:x:/@p5.mysql.select/*

    /*
     * First adding [item] to databind invocation.
     */
    add:x:/../*/micro.widgets.grid.databind
      src:item

    /*
     * Then looping through each cell, making sure we HTML encode it before we
     * append it's value into currently iterated [item].
     */
    for-each:x:/@_dp/#/*(!/id)

      /*
       * Special handling of "checkbox" type of items, to create some candy.
       */
      if:x:/@load-file/@load-file/*/*/field/*/name/={0}/./*/type?value
        :x:/@_dp/#?name
        =:checkbox

        /*
         * Checkbox type of item.
         */
        if:x:/@_dp/#?value.int
          =:int:1

          /*
           * Item is checked.
           */
          set:x:/+/*/*?name
            src:x:/@_dp/#?name
          add:x:/../*/micro.widgets.grid.databind/0/-
            src
              foo:@"<span class=""icon-check""></span>"
                style:"text-align:right;width:5px;font-size:1.5rem;"

        else

          /*
           * Item is NOT checked.
           */
          set:x:/+/*/*?name
            src:x:/@_dp/#?name
          add:x:/../*/micro.widgets.grid.databind/0/-
            src
              foo:""
                style:"width:5px;"

      else-if:x:/@load-file/@load-file/*/*/field/*/name/={0}/./*/type?value
        :x:/@_dp/#?name
        =:textarea

        /*
         * Textarea's content is turned into Markdown using intelligent parsing.
         */
        eval-x:x:/+/*
        camphora._internal.html.markdown2html:x:/@_dp/#?value
          app-name:x:/../*/split/[0,1]/1?name

        /*
         * Adding item to grid's databind invocation.
         */
        eval-x:x:/+2/*/**
        set:x:/+/*/*?name
          src:x:/@_dp/#?name
        add:x:/../*/micro.widgets.grid.databind/0/-
          src
            foo:x:/@camphora._internal.html.markdown2html?value
              .data-field:x:/@_dp/#?name

      else-if:x:/@load-file/@load-file/*/*/field/*/name/={0}/./*/type?value
        :x:/@_dp/#?name
        =:text
        or:x:/@load-file/@load-file/*/*/field/*/name/={0}/./*/type?value
          :x:/@_dp/#?name
          =:radio
        or:x:/@load-file/@load-file/*/*/field/*/name/={0}/./*/type?value
          :x:/@_dp/#?name
          =:select

        /*
         * Text widgets, select widget, and radio widgets are rendered as "nowrap", 
         * in addition to that their values are HTML encoded, to avoid HTML injection in items.
         */
        p5.html.html-encode:x:/@_dp/#?value

        /*
         * Adding item to grid's databind invocation.
         */
        eval-x:x:/+2/*/**
        set:x:/+/*/*?name
          src:x:/@_dp/#?name
        add:x:/../*/micro.widgets.grid.databind/0/-
          src
            foo:x:/@p5.html.html-encode?value
              .data-field:x:/@_dp/#?name
              style:"white-space:nowrap;"

    /*
     * Checking if user is allowed to edit items in system, and if he is, 
     * we add our "Edit row" cell.
     */
    if:x:/@p5.web.viewstate.get/*?value

      /*
       * User is allowed to edit rows, loading our file that contains our "Edit row"
       * template, and adding it into invocation that adds row to grid.
       */
      add:x:/..for-each/*/add/[1,2]/*/src
        src:x:/@load-file/*/*

    /*
     * Adding row to grid.
     */
    eval-x:x:/+/*/*/.row/*/.id
    add:x:/../*/micro.widgets.grid.databind/0/-
      src
        .row
          .id:x:/@_dp/#/*/id?value





/*
 * Checking if this is a "replace" operation, at which point an [id] argument
 * was specified.
 */
if:x:/../*/id?value

  /*
   * Making sure our item replaces existing grid item, instead of appending.
   */
  p5.web.widgets.find
    .id:x:/../*/id?value
  add:x:/../*/micro.widgets.grid.databind
    src
      keep-items:bool:true
  eval-x:x:/+/*/*
  add:x:/../*/micro.widgets.grid.databind/*/*/.row
    src
      .replace:x:/@p5.web.widgets.find/*/*?value





/*
 * Checking if this is a "feed more" invocation, at which point we don't clean
 * out existing items in grid.
 */
add:x:/../*/micro.widgets.grid.databind
  src
    keep-items:bool:true





/*
 * Databinding grid.
 */
micro.widgets.grid.databind:camphora-crud-grid
