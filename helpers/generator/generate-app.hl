/*
 * File responsible for generating a Camphora Five CRUD app from a manifest file.
 *
 * Expects a __[filename]__ argument, declaring which app to generate.
 * Optionally pass in a __[delete-data]__ argument, and set its value to boolean _"true"_
 * if you wish to delete existing data/database/table for app.
 */





/*
 * Sanity checking arguments.
 */
micro.lambda.contract.min:x:/..
  filename:string
micro.lambda.contract.optional:x:/..
  delete-data:bool





/*
 * Figuring out app's name, which becomes its default
 * folder, and its database table name.
 */
split:x:/../*/filename?value
  =:/
  =:.





/*
 * Checking if folder exists from before, and if it does,
 * we try to uninstall the module, and delete its folder afterwards.
 */
if
  fetch:x:/0/0?value
    folder-exists:/modules/{0}/
      :x:/@split/0/-2?name
  if
    fetch:x:/0/0?value
      file-exists:/modules/{0}/uninstall.hl
    micro.evaluate.file:/modules/{0}/uninstall.hl
  delete-folder:/modules/{0}/
    :x:/@split/0/-2?name





/*
 * Creating root folder for our app.
 */
copy-folder:@CAMPHORA/template/
  dest:/modules/{0}/
    :x:/@split/0/-2?name





/*
 * Loading manifest file.
 */
load-file:x:/../*/filename?value





/*
 * Checking if manifest for application specified that we should create a
 * desktop icon, or not.
 */
if:x:/@load-file/*/*/desktop-icon?value
  =:bool:false

  /*
   * Deleting desktop icon for app, since app should not have one.
   */
  delete-file:/modules/{0}/desktop.hl
    :x:/@split/0/-2?name





/*
 * Creating one 'view' file for each [view] in our manifest file.
 */
for-each:x:/@load-file/*/*/views/*
  save-file:/modules/{0}/views/{1}.hl
    :x:/@split/0/-2?name
    :x:/@_dp/#?name
    src:{0}{1}
      :@"/*
 * This file was auto-generated by Camphora Five.
 *
 * Edit it at your own risk, since it might be overwritten
 * if the app is re-generated!
 */

"
      :x:/@_dp/#?value





/*
 * Trying to delete old database table, if it exists, and if caller told us to do so.
 */
if:x:/../*/delete-data?value
  try
    p5.mysql.connect:[camphora]
      p5.mysql.execute:@"drop table `{0}`"
        :x:/@split/0/-2?name
  catch

    /*
     * Silent catch, since exception implies database/table didn't exist.
     */





/*
 * Creating our actual MySQL datagrid according to our CRUD app
 * manifest file's content.
 *
 * We do this by loading the "camphora.widgets.datagrid.hl" file and
 * modify the datagrid inside of it, according to the [field] definitions
 * found in our app manifest file.
 *
 * Notice, we make sure we only add visible fields into the actual datagrid.
 */
load-file:/modules/{0}/startup/widgets/camphora.widgets.datagrid.hl
  :x:/@split/0/-2?name
  convert:false
hyper2lambda:x:/@load-file/*?value
  keep-comments:true
for-each:x:@"/../*/load-file/[0,1]/*/*/field(/*/show/""=:bool:true"")/."

  /*
   * Used as a buffer for currently iterated column declaration.
   */
  .column
    foo
      .header
        widgets
          button
            title:Sort by {0}
              :x:/@_dp/#/*/name?value
            innerValue:@"<span></span> {0}"
              :x:/@_dp/#/*/name?value
            .column:x:/@_dp/#/*/name?value
            onclick

              /*
               * Getting [column] value that we should sort by.
               */
              get-widget-property:x:/../*/_event?value
                .column
                class

              /*
               * Doing the actual sorting.
               */
              p5.web.widgets.find-first-ancestor:x:/../*/_event?value
                .datagrid

              /*
               * Deleting sort order CSS classes on all header buttons, except
               * the currently clicked one.
               */
              p5.web.widgets.find-like:x:/@p5.web.widgets.find-first-ancestor/*/*?value
                class:camphora-sort-column
                .column
              micro.css.delete:x:/@p5.web.widgets.find-like/*/*(!/={0})?value
                :x:/../*/_event?value
                class:camphora-sort-column-asc camphora-sort-column-desc

              /*
               * Checking if we're already sorting by this column.
               */
              if:x:/@get-widget-property/*/*/class?value
                ~:camphora-sort-column-asc

                /*
                 * We're already sorting ascending, making sure we sort descending.
                 */
                micro.css.add:x:/../*/_event?value
                  class:camphora-sort-column-desc
                micro.css.delete:x:/../*/_event?value
                  class:camphora-sort-column-asc
                eval-x:x:/+/*
                camphora.datagrid.sort:x:/@p5.web.widgets.find-first-ancestor/*/*?value
                  column:x:/@get-widget-property/*/*/.column?value
                  order-dir:desc

              else-if:x:/@get-widget-property/*/*/class?value
                ~:camphora-sort-column-desc

                /*
                 * We're alread sorting descending, removing sorting entirely
                 */
                micro.css.delete:x:/../*/_event?value
                  class:camphora-sort-column-desc
                eval-x:x:/+/*
                camphora.datagrid.databind:x:/@p5.web.widgets.find-first-ancestor/*/*?value
                  order-by
                  order-dir

              else

                /*
                 * Sorting ascending if no existing sort order extsts.
                 */
                micro.css.add:x:/../*/_event?value
                  class:camphora-sort-column-asc
                eval-x:x:/+/*
                camphora.datagrid.sort:x:/@p5.web.widgets.find-first-ancestor/*/*?value
                  column:x:/@get-widget-property/*/*/.column?value
                  order-dir:asc

  /*
   * Setting the column's name, forward declaring its [innerValue],
   * and all [.column] references inside of it.
   */
  set:x:/@.column/*?name
    src:x:/@_dp/#/*/name?value
  eval-x:x:/@.column/**(/innerValue|/.column|/title)

  /*
   * Checking if this is a checkbox type of column, at which point
   * we make sure its value is displayed as a check mark if its value
   * is actually checked.
   */
  if:x:/@_dp/#/*/type?value
    =:checkbox

    /*
     * Checkbox type of column, making sure we display its value
     * as a checkmark, by making it become a [.lambda] type of column, and
     * making sure it becomes fixed width, to avoid having column take up
     * so much space in datagrid.
     */
    add:x:/@.column/*/*/.header
      src
        class:camphora-checkbox-column
    add:x:/@.column/*
      src
        class:camphora-checkbox-column
    eval-x:x:/+/*/*/*/.field-name
    add:x:/@.column/*
      src
        .lambda

          /*
           * Forward evaluated above.
           */
          .field-name:x:/@_dp/#/*/name?value

          /*
           * Checking if checkbox value should be checked.
           */
          if:x:/../*/row/*/{0}?value
            :x:/@.field-name?value
            =:int:1

            /*
             * We should create a checkbox icon.
             */
            return
              literal
                element:span
                class:icon-checkmark

    /*
     * Since a [.lambda] column isn't part of the SQL executed towards the
     * database, we'll need to also add an invisible column with the name of
     * our checkbox column.
     */
    set:x:/+/*/*?name
      src:x:/@_dp/#/*/name?value
    add:x:/@.column
      src
        foo
          visible:bool:false

  /*
   * Checking if this is a multiline textarea type of widget, at which point
   * we make sure we display it as pre formatted.
   */
  else-if:x:/@_dp/#/*/type?value
    =:textarea

    /*
     * Applying preformatted class to the cell.
     */
    add:x:/@.column/*
      src
        class:camphora-pre-cell

  /*
   * Checking if this is a Markdown type of field, at which point
   * we make sure we display it as pre formatted, and convert it to
   * HTML, before we display it in the datagrid.
   */
  else-if:x:/@_dp/#/*/type?value
    =:markdown

    /*
     * Markdown type of field, making sure we transform content to HTML,
     * in addition to displaying cell's content as pre-formatted.
     */
    eval-x:x:/+/*/*/*(/.app-name|/.field-name)
    add:x:/@.column/*
      src
        .lambda

          /*
           * Forward evaluated above.
           */
          .field-name:x:/@_dp/#/*/name?value
          .app-name:x:/../*/split/0/-2?name

          /*
           * Checking if there actually is any Markdown content.
           */
          eval-x:x:/+
          .content:x:/../*/row/*/{0}?value
            :x:/@.field-name?value
          if:x:/@.content?value
            not
            or:x:/@.content?value
              =:

              /*
               * Nothing to do here, wmpty value, returning to avoid
               * evaluation of the rest of our lambda.
               */
              return

          /*
           * Transforming Markdown to HMTL.
           */
          markdown2html:x:/@.content?value

          /*
           * Semantically sanity checking Markdown according to HTML
           * whitelist, to avoid injection of malicious HTML tags.
           */
          html2lambda:x:/@markdown2html?value
          load-file:/modules/{0}/configuration/html-whitelist.hl
            :x:/@.app-name?value
          for-each:x:/@html2lambda/**
            if:x:/@load-file/*/*/\{0}
              :x:/@_dp/#?name
              not

              /*
               * Illegals HTML tag, hence removing it.
               */
              set:x:/@_dp/#

          /*
           * Transforming lambda to HTML again.
           */
          lambda2html:x:/@html2lambda/*

          /*
           * Returning item to caller.
           *
           * Notice, to make it possible to actually click hyperlinks
           * inside of our markdown cells, we'll have to explicitly allow
           * that by stopping propagation of click event - Since otherwise
           * the default [onclick] event handler for the row as a whole
           * would prevent Hyperlinks from being possible to actually click.
           */
          eval-x:x:/+/*/*/innerValue
          return
            literal
              element:div
              onclick:event.stopPropagation();
              class:camphora-no-pointer-cursor
              innerValue:x:/@lambda2html?value

    /*
     * Since a [.lambda] column isn't part of the SQL executed towards the
     * database, we'll need to also add an invisible column with the name of
     * our markdown column.
     */
    set:x:/+/*/*?name
      src:x:/@_dp/#/*/name?value
    add:x:/@.column
      src
        foo
          visible:bool:false

  /*
   * Adding column to [columns] declaration of MySQL datagrid.
   */
  add:x:/@hyper2lambda/**/micro.widgets.mysql.datagrid/*/columns
    src:x:/@.column/*





/*
 * Saving file again, now with [columns] declarations, making sure we
 * get its filename correctly, while deleting the old (outdated) file.
 */
lambda2hyper:x:/@hyper2lambda/*
  comments:unroll
save-file:/modules/{0}/startup/widgets/camphora.{0}.widgets.datagrid.hl
  :x:/@split/0/-2?name
  src:x:/@lambda2hyper?value
delete-file:/modules/{0}/startup/widgets/camphora.widgets.datagrid.hl
  :x:/@split/0/-2?name





/*
 * Renaming name of "camphora.widgets.toolbar.hl" file, to make sure its
 * filename correctly declares what widget it actually creates.
 */
move-file:/modules/{0}/startup/widgets/camphora.widgets.toolbar.hl
  :x:/@split/0/-2?name
  dest:/modules/{0}/startup/widgets/camphora.{0}.widgets.toolbar.hl
    :x:/@split/0/-2?name





/*
 * Creating our "insert new item" file, according to app manifest file.
 *
 * We do this by loading the "create-item.hl" file and modify the
 * form collection inside of it according to what fields our app has.
 */
load-file:/modules/{0}/helpers/create-item.hl
  :x:/@split/0/-2?name
  convert:false
hyper2lambda:x:/@load-file/*?value
  keep-comments:true
add:x:/+/*
  src:x:/../*/load-file/[0,1]/*/*/field
add:x:/@hyper2lambda/*/create-widgets/**/widgets/=data
  micro.evaluate.file:@CAMPHORA/helpers/generator/create-new-item-widgets.hl
lambda2hyper:x:/@hyper2lambda/*
  comments:unroll
save-file:/modules/{0}/helpers/create-item.hl
  :x:/@split/0/-2?name
  src:x:/@lambda2hyper?value





/*
 * Making sure our "default.hl" file does not have a navbar if
 * there are no views in our app.
 *
 * We do this by checking if there are no views in the app, and if
 * not, we load the "default.hl" file, and entirely remove the wrapper
 * that wraps our "view navbar".
 */
if:x:/../*/load-file/[0,1]/*/*/views/*
  not

  /*
   * Removing navbar from "default.hl" file.
   */
  load-file:/modules/{0}/views/default.hl
    :x:/@split/0/-2?name
    convert:false
  hyper2lambda:x:/@load-file/*?value
    keep-comments:true
  set:x:/@hyper2lambda/*/create-widget/**/widgets/*/micro.widgets.tree/./././.
  lambda2hyper:x:/@hyper2lambda/*
    comments:unroll
  save-file:/modules/{0}/views/default.hl
    :x:/@split/0/-2?name
    src:x:/@lambda2hyper?value





/*
 * Making sure that our "edit-item.hl" file knows how many visible columns
 * there are in the datagrid in total in its [.column-count] node - In addition
 * to creating its form collection for editing an item.
 */
load-file:/modules/{0}/helpers/edit-item.hl
  :x:/@split/0/-2?name
  convert:false
hyper2lambda:x:/@load-file/*?value
  keep-comments:true
set:x:/@hyper2lambda/*/.column-count?value
  src:x:@"/../*/load-file/[0,1]/*/*/field/*/show/""=:bool:true""?count"
add:x:/+/*
  src:x:/../*/load-file/[0,1]/*/*/field
add:x:/@hyper2lambda/*/create-widget/**/widgets/=data
  micro.evaluate.file:@CAMPHORA/helpers/generator/create-edit-item-widgets.hl
lambda2hyper:x:/@hyper2lambda/*
  comments:unroll
save-file:/modules/{0}/helpers/edit-item.hl
  :x:/@split/0/-2?name
  src:x:/@lambda2hyper?value





/*
 * Making sure that our "download-items.hl" file knows which columns to export.
 */
load-file:/modules/{0}/helpers/download-items.hl
  :x:/@split/0/-2?name
  convert:false
hyper2lambda:x:/@load-file/*?value
  keep-comments:true
add:x:/@hyper2lambda/**/.fields
  src:x:/../*/load-file/[0,1]/*/*/field
lambda2hyper:x:/@hyper2lambda/*
  comments:unroll
save-file:/modules/{0}/helpers/download-items.hl
  :x:/@split/0/-2?name
  src:x:/@lambda2hyper?value





/*
 * Making sure our "search-datagrid.hl" file knows which columns we can apply filtering
 * to, and how.
 */
load-file:/modules/{0}/helpers/search-datagrid.hl
  :x:/@split/0/-2?name
  convert:false
hyper2lambda:x:/@load-file/*?value
  keep-comments:true
add:x:/@hyper2lambda/*/.fields
  src:x:/../*/load-file/[0,1]/*/*/field
lambda2hyper:x:/@hyper2lambda/*
  comments:unroll
save-file:/modules/{0}/helpers/search-datagrid.hl
  :x:/@split/0/-2?name
  src:x:/@lambda2hyper?value





/*
 * Creating our "create database" file, according to app manifest file.
 *
 * We do this by loading the "create-database.hl" file and add up the field
 * declarations from our manifest file.
 */
load-file:/modules/{0}/startup/create-database.hl
  :x:/@split/0/-2?name
  convert:false
hyper2lambda:x:/@load-file/*?value
  keep-comments:true
add:x:/@hyper2lambda/**/.fields
  src:x:/../*/load-file/[0,1]/*/*/field
lambda2hyper:x:/@hyper2lambda/*
  comments:unroll
save-file:/modules/{0}/startup/create-database.hl
  :x:/@split/0/-2?name
  src:x:/@lambda2hyper?value





/*
 * Making sure we replace '{app-name}' and event names in all nodes,
 * in all files, inside module's folder.
 *
 * Notice, we must do this last, since some of the processes above will
 * create references to Active Events and such.
 */
eval-x:x:/+/*
micro.evaluate.file:@CAMPHORA/helpers/generator/replace-app-name.hl
  folder:/modules/{0}/
    :x:/@split/0/-2?name
  app-name:x:/@split/0/-2?name





/*
 * Evaluating startup file for app, which effectively will "install" the
 * app, by creating its database, Active Events and extension widgets.
 */
micro.evaluate.file:/modules/{0}/startup.hl
  :x:/@split/0/-2?name
